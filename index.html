<!doctype html>
<html>

<head>
    <meta charset="UTF-8" />
    <title>Prison Capacity</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        canvas {
            background: gray;
            padding: 0;
            margin: auto;
            display: block;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
        }

        .ml12 {
            font-weight: 200;
            font-size: 1.8em;
            text-transform: uppercase;
            letter-spacing: 0.5em;
            text-align: center;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .ml12 .letter {
            display: inline-block;
            line-height: 1em;
        }
        input {
            outline: 0;
            border-width: 0 0 2px;
            border-color: black;
            background: none;
            font-weight: 200;
            font-size: 1.8em;
            text-transform: uppercase;
            letter-spacing: 0.5em;
        }
        input:focus {
            border-color: green
        }

        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
        -webkit-appearance: none; 
        margin: 0; 
        }
    </style>
    <link rel="stylesheet" type="text/css" href="./css/index.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/rough.js/2.2.5/rough.min.js"></script>
    <script src="src/inmate.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/2.0.2/anime.min.js"></script>
</head>

<canvas id="myCanvas" margin="auto"></canvas>
<div class="ml12">
    <form onsubmit="setOccupancy(); return false">
        <label for="number" ># of inmates: <input type="number" id="number" name="number"></input></label>
    </form>
</div>

<script>
    // Wrap every letter in a span
    var textWrapper = document.querySelector('.ml12');
    // textWrapper.innerHTML = textWrapper.textContent.replace(/\S/g, "<span class='letter'>$&</span>");

    var animation = anime.timeline({})
        .add({
            // targets: '.ml12 .letter',
            targets: '.ml12',
            // translateX: [40, 0],
            // translateZ: 0,
            opacity: [0, 1],
            easing: "easeOutExpo",
            duration: 1200,
            delay: (el, i) => 500 + 30 * i,
            complete: () => animation.pause()
        })
        .add({
            targets: '.ml12',
            // translateX: [0, -30],
            opacity: [1, 0],
            easing: "easeInExpo",
            duration: 1100,
            delay: (el, i) => 100 + 30 * i,
        });
    
    function setOccupancy() {
        animation.play()
        inmates = Number(document.querySelector('#number').value)
        setInmates();
        drawInmates();
        draw();
    }

    var canvas = (document.getElementById("myCanvas"));
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    var ctx = canvas.getContext("2d");
    var x = 10;
    var y = 10;
    var inmate = 0
    var inmates;
    var inmatePos;
    var personalSpace;
    var personalWidth;
    var personalHeight;

    function setInmates() {
        inmate = 0;
        inmates = Number(document.querySelector('#number').value);
        inmatePos = [];
        for (let i = 0; i < inmates; i++) {
            inmatePos[i] = new Inmate(0, 0, 10);
        }
        personalSpace = (canvas.width * canvas.height) / inmates;
        personalWidth = Math.sqrt(personalSpace / (canvas.width / canvas.height)) * (canvas.width / canvas.height);
        personalHeight = Math.sqrt(personalSpace / (canvas.width / canvas.height));
    }

    function drawInmates() {
        y = 10
        while (inmate < inmates) {
            for (let i = 0; i + personalWidth < canvas.width && inmate < inmates; i += personalWidth) {
                drawFrame(CYCLE_LOOP[inmatePos[inmate]["currentLoopIndex"]], inmatePos[inmate]["currentDirection"], inmatePos[inmate]["x"] += x, inmatePos[inmate]["y"] += y);
                x += personalWidth;
                inmate++;
            }
            x = 10;
            if (y + personalHeight < canvas.height) {
                y += personalHeight;
            } else {
                y = canvas.height - 10;
            }
        }
        x = 20;
        y = 20;
    }

    function moveInmates() {
        inmate = 0
        while (inmate < inmates) {
            drawFrame(CYCLE_LOOP[inmatePos[inmate]["currentLoopIndex"]], inmatePos[inmate]["currentDirection"], inmatePos[inmate]["x"], inmatePos[inmate]["y"]);
            inmate++
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        moveInmates();
        inmate = 0
        while (inmate < inmates) {
            inmatePos[inmate]["x"] += inmatePos[inmate]["dx"];
            inmatePos[inmate]["y"] += inmatePos[inmate]["dy"];
            if (inmatePos[inmate]["x"] + inmatePos[inmate]["dx"] > canvas.width - inmatePos[inmate]["radius"] * 3 || inmatePos[inmate]["x"] + inmatePos[inmate]["dx"] < 0) {
                inmatePos[inmate]["dx"] = -inmatePos[inmate]["dx"];
                inmatePos[inmate]["dx"] > 0 ? inmatePos[inmate]["currentDirection"] = FACING_RIGHT : inmatePos[inmate]["currentDirection"] = FACING_LEFT;
            }
            if (inmatePos[inmate]["y"] + inmatePos[inmate]["dy"] < 0 || inmatePos[inmate]["y"] + inmatePos[inmate]["dy"] > canvas.height - inmatePos[inmate]["radius"]) {
                inmatePos[inmate]["dy"] = -inmatePos[inmate]["dy"];
                inmatePos[inmate]["dy"] > 0 ? inmatePos[inmate]["currentDirection"] = FACING_DOWN : inmatePos[inmate]["currentDirection"] = FACING_UP;
            }
            inmatePos[inmate]["levee"]++
            if (inmatePos[inmate]["levee"] >= 14) {
                inmatePos[inmate]["currentLoopIndex"] = (inmatePos[inmate]["currentLoopIndex"] + 1) % 4
                inmatePos[inmate]["levee"] = 0;
            }
            inmate++
        }
        collisionDetection();
        requestAnimationFrame(draw);
    }

    function distance(a, b) {
        return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }

    function collisionDetection() {
        for (let i = 0; i < inmates - 1; i++) {
            for (let j = i + 1; j < inmates; j++) {
                if (distance(inmatePos[i], inmatePos[j]) <= inmatePos[i]["radius"] * 2) {
                    let theta1 = inmatePos[i].angle();
                    let theta2 = inmatePos[j].angle();
                    let phi = Math.atan2(inmatePos[j].y - inmatePos[i].y, inmatePos[j].x - inmatePos[i].x);
                    let m1 = inmatePos[i].mass;
                    let m2 = inmatePos[j].mass;
                    let v1 = inmatePos[i].speed();
                    let v2 = inmatePos[j].speed();

                    let idx = (v1 * Math.cos(theta1 - phi) * (m1 - m2) + 2 * m2 * v2 * Math.cos(theta2 - phi)) / (m1 + m2) * Math.cos(phi) + v1 * Math.sin(theta1 - phi) * Math.cos(phi + Math.PI / 2);
                    let idy = (v1 * Math.cos(theta1 - phi) * (m1 - m2) + 2 * m2 * v2 * Math.cos(theta2 - phi)) / (m1 + m2) * Math.sin(phi) + v1 * Math.sin(theta1 - phi) * Math.sin(phi + Math.PI / 2);
                    let jdx = (v2 * Math.cos(theta2 - phi) * (m2 - m1) + 2 * m1 * v1 * Math.cos(theta1 - phi)) / (m1 + m2) * Math.cos(phi) + v2 * Math.sin(theta2 - phi) * Math.cos(phi + Math.PI / 2);
                    let jdy = (v2 * Math.cos(theta2 - phi) * (m2 - m1) + 2 * m1 * v1 * Math.cos(theta1 - phi)) / (m1 + m2) * Math.sin(phi) + v2 * Math.sin(theta2 - phi) * Math.sin(phi + Math.PI / 2);

                    inmatePos[i]["dx"] = idx > 1.2 ? 1.2 : idx < -1.2 ? -1.2 : idx;
                    inmatePos[i]["dy"] = idy > 1.2 ? 1.2 : idy < -1.2 ? -1.2 : idy;
                    inmatePos[j]["dx"] = jdx > 1.2 ? 1.2 : jdx < -1.2 ? -1.2 : jdx;
                    inmatePos[j]["dy"] = jdy > 1.2 ? 1.2 : jdy < -1.2 ? -1.2 : jdy;

                    // inmatePos[i]["dx"] = inmatePos[i]["dx"] > 0 ? Math.random() * -1.2 : Math.random() * 1.2;
                    // inmatePos[i]["dy"] = inmatePos[i]["dy"] > 0 ? Math.random() * -1.2 : Math.random() * 1.2;
                    // inmatePos[j]["dx"] = inmatePos[j]["dx"] > 0 ? Math.random() * -1.2 : Math.random() * 1.2;
                    // inmatePos[j]["dy"] = inmatePos[j]["dy"] > 0 ? Math.random() * -1.2 : Math.random() * 1.2;

                    // inmatePos[i]["dx"] > 0 ? inmatePos[i]["currentDirection"] = FACING_RIGHT : inmatePos[i]["currentDirection"] = FACING_LEFT;
                    // inmatePos[i]["dy"] > 0 ? inmatePos[i]["currentDirection"] = FACING_RIGHT : inmatePos[i]["currentDirection"] = FACING_LEFT;
                    // inmatePos[j]["dx"] > 0 ? inmatePos[j]["currentDirection"] = FACING_DOWN : inmatePos[j]["currentDirection"] = FACING_UP;
                    // inmatePos[j]["dy"] > 0 ? inmatePos[j]["currentDirection"] = FACING_DOWN : inmatePos[j]["currentDirection"] = FACING_UP;

                    if (Math.abs(inmatePos[i]["dy"]) > Math.abs(inmatePos[i]["dx"])) {
                        inmatePos[i]["dy"] > 0 ? inmatePos[i]["currentDirection"] = FACING_DOWN : inmatePos[i]["currentDirection"] = FACING_UP;
                    } else {
                        inmatePos[i]["dx"] > 0 ? inmatePos[i]["currentDirection"] = FACING_RIGHT : inmatePos[i]["currentDirection"] = FACING_LEFT;
                    }

                    if (Math.abs(inmatePos[j]["dy"]) > Math.abs(inmatePos[j]["dx"])) {
                        inmatePos[j]["dy"] > 0 ? inmatePos[j]["currentDirection"] = FACING_DOWN : inmatePos[j]["currentDirection"] = FACING_UP;
                    } else {
                        inmatePos[j]["dx"] > 0 ? inmatePos[j]["currentDirection"] = FACING_RIGHT : inmatePos[j]["currentDirection"] = FACING_LEFT;
                    }
                }
            }
        }
    }

    let img = new Image();
    img.src = 'https://opengameart.org/sites/default/files/Green-Cap-Character-16x18.png';
    // img.onload = function () {
    //     drawInmates();
    //     draw();
    // };

    const SCALE = 1.5;
    const WIDTH = 16;
    const HEIGHT = 18;
    const SCALED_WIDTH = SCALE * WIDTH;
    const SCALED_HEIGHT = SCALE * HEIGHT;
    
    const FACING_DOWN = 0;
    const FACING_UP = 1;
    const FACING_LEFT = 2;
    const FACING_RIGHT = 3;
    
    const CYCLE_LOOP = [0, 1, 0, 2];
    let frameCount = 0;

    function drawFrame(frameX, frameY, canvasX, canvasY) {
        ctx.drawImage(img,
            frameX * WIDTH, frameY * HEIGHT, WIDTH, HEIGHT,
            canvasX, canvasY, SCALED_WIDTH, SCALED_HEIGHT);
    }
</script>

<body>
    <!-- <script src="./dist/main.js"></script> -->
</body>

</html>